path <- httr::modify_url(server, path = paste0("/api/v0/",table))
# Post a line of data
httr::POST(path, body = substr(table_lst_line, 2, (nchar(table_lst_line))-1), config = add_headers("Content-type" = "application/json"))
}
print("POST_line extracted")
test_that("Warning for object that are not json data", {
expect_error(POST_line(c(1:5), "table"), "'table_lst_line' must be a json")
})
POST_line(c(1:5), "table")
data <- to_json(list("fruit" = "apple", "vegetable" = "carrot"))
library(jsonlite)
data <- to_json(list("fruit" = "apple", "vegetable" = "carrot"))
data <- toJSON(list("fruit" = "apple", "vegetable" = "carrot"))
data
POST_line(data, "error")
status(POST_line(data, "error"))
http_status(POST_line(data, "error"))
http_code(POST_line(data, "error"))
http_type(POST_line(data, "error"))
r <- GET("http://httpbin.org/get")
headers(r)
rm(r)
http_status(POST_line(data, "error"))[[3]]
http_status((POST_line(data, "error"))[[3]])
test_that("Connect to table", {
expect_match(http_status(POST_line(data, "error"))[[3]], "404")
})
data <- "[{"fruit":"apple";"vegetable":"carrot"}]"
data <- [{"fruit":"apple";"vegetable":"carrot"}]
data <- as.character([{"fruit":"apple";"vegetable":"carrot"}])
data <- list([{"fruit":"apple";"vegetable":"carrot"}])
data <- list(c("[{"fruit":"apple";"vegetable":"carrot"}])"))
data <- toJSON(data.frame(c(1:5)))
View(data1)
data.frame(c(1:5))
data
data <- toJSON(data.frame(c(1:5)), dataframe = row)
data <- toJSON(data.frame(c(1:5)), dataframe = "row")
data
data <- toJSON(data.frame(c(1:5)), dataframe = "column")
data
head(cars)
cars[,1]
cars[1,]
data <- toJSON(cars[1,])
data
test_that("Connect to table", {
expect_match(http_status(POST_line(data, "error"))[[3]], "404")
})
POST_line(data, "error")
data <- toJSON(cars[c(1:3),])
data
data <- toJSON(data.frame(cars[c(1:3),]))
data
data <- toJSON(list(cars[c(1:3),]))
data
cars[c(1:3),]
data
data <- as.list(setNames(split(data, seq(nrow(df))), rownames(df)))
data <- as.list(setNames((data, seq(nrow(df))), rownames(df)))
data <- as.list(setNames((data, seq(nrow(df))))
data <- as.list(setNames(split(data, seq(nrow(data))), rownames(data)))
data <- as.list(c(toJSON(cars[1,]), toJSON(cars[2,]), toJSON(cars[3,]))
)
data
data <- toJSON(cars[1,])
dat
data
data <- as.list(toJSON(cars[1,]), toJSON(cars[2,]), toJSON(cars[3,]))
data
data <- as.list(1 = toJSON(cars[1,]), 2 = toJSON(cars[2,]), 3 = toJSON(cars[3,]))
data <- as.list("1" = toJSON(cars[1,]), "2" = toJSON(cars[2,]), "3" = toJSON(cars[3,]))
data <- list("1" = toJSON(cars[1,]), "2" = toJSON(cars[2,]), "3" = toJSON(cars[3,]))
data
data <- list(toJSON(cars[1,]), toJSON(cars[2,]), toJSON(cars[3,]))
data
data <- []
data <- "[]"
data
data <- "[{"speed":4,"dist":2}]"
data <- text([{"speed":4,"dist":2}])
data <- text("[{"speed":4,"dist":2}]")
test_that("Connect to table", {
expect_match(http_status(POST_line(data, "error"))[[3]], "404")
#  expect_match(http_status(POST_line("@@@", "@@@"))[[3]], "200")
})
data <- toJSON(cars[1,])
test_that("Connect to table", {
expect_match(http_status(POST_line(data, "error"))[[3]], "404")
#  expect_match(http_status(POST_line("@@@", "@@@"))[[3]], "200")
})
?data.frame
library(mangal)
df <- data.frame(value = C(1:5), row.names = c(1:5))
df <- data.frame(value = C(1:5), row.names = c("name", "id")
df <- data.frame(value = C(1:5), row.names = c("name", "id")
)
df <- data.frame(value = C(1:5), row.names = c("name", "id"))
df <- data.frame(row.names = c("name", "id"))
fd
df
df[1,] <- c("test1", "test2")
df[,1] <- c("test1", "test2")
df[,2] <- c(1:2)
df
df <- data.frame(col.names = c("name", "id"))
df[,1] <- c("test1", "test2")
df[,2] <- c(1:2)
df
df <- data.frame(names, id)
df <- data.frame(col.names = c("name", "id"))
df
df <- data.frame(name = c("test1", "test2", id = c(1:2)))
df
df <- data.frame(name = c("test1", "test2")
)
df[,2] <- c(1:2)
df
bib[,2] <- NA
df <- colnames(c("name", "id"))
df
df <- data.frame(name = c("test1", "test2"))
df[,2] <- c(1:2)
df <- colnames(c("name", "id"))
df
df <- data.frame(name = c("test1", "test2"))
df
df[,2] <- c(1:2)
df
df <- colnames(c("name", "id"))
df
?colnames
df <- data.frame(name = c("test1", "test2"))
df[,2] <- c(1:2)
colnames( df, c("name", "id"))
colnames(df) <- c("name", "id")
df <- data.frame(name = c("test1", "test2"))
df[,2] <- c(1:2)
colnames(df) <- c("name", "id")
df
json_list(df)
test_that("Status of the request is store", {
expect_output(POST_table(dataB, users), "")
})
#' @title POST many lines of json data on a same Mangal table
#'
#' @description POST a list of json data in the Mangal table specified by the user
#'
#' @param data_lst A list with data to be injected, must be json
#' @param table A element, must be the name of the targeted table with ""
#'
#' @return
#'
#' The status and line of failed attempt; if none -> empty
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom httr http_error
#' @importFrom httr http_status
POST_table <- function(data_lst, table) {
# Create vector of status that will contain line + error message
status <- vector()
# Stock responce status for 1 iteration
resp <- character()
# loop : POST one by one each line of the table
for (j in 1:length(data_lst)) {
# Get the status of the POST in resp
resp <- POST_line(data_lst[[j]], table)
# Check if status code other than "Created"
if(httr::http_error(resp) = TRUE){
# If so, paste line + status message
status[length(status)+1] <- paste(j, httr::http_status(resp)[[3]])
}
}
# View wich request failed
if(length(status) != 0){
print(status)
}
}
print("POST_table extracted")
test_that("Status of the request is store", {
expect_output(POST_table(dataB, users), "")
})
#' @title POST many lines of json data on a same Mangal table
#'
#' @description POST a list of json data in the Mangal table specified by the user
#'
#' @param data_lst A list with data to be injected, must be json
#' @param table A element, must be the name of the targeted table with ""
#'
#' @return
#'
#' The status and line of failed attempt; if none -> empty
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom httr http_error
#' @importFrom httr http_status
POST_table <- function(data_lst, table) {
# Create vector of status that will contain line + error message
status <- vector()
# Stock responce status for 1 iteration
resp <- character()
# loop : POST one by one each line of the table
for (j in 1:length(data_lst)) {
# Get the status of the POST in resp
resp <- POST_line(data_lst[[j]], table)
# Check if status code other than "Created"
if(httr::http_error(resp) == TRUE){
# If so, paste line + status message
status[length(status)+1] <- paste(j, httr::http_status(resp)[[3]])
}
}
# View wich request failed
if(length(status) != 0){
print(status)
}
}
print("POST_table extracted")
test_that("Status of the request is store", {
expect_output(POST_table(dataB, users), "")
})
dataB <- data.frame(name = c("test1", "test2"))
dataB[,2] <- c(1:2)
colnames(dataB) <- c("name", "id")
test_that("Status of the request is store", {
expect_output(POST_table(dataB, users), "")
})
dataB <- json_list(dataB)
dataB
dataA <- list(toJSON(cars[1,]), toJSON(cars[2,]), toJSON(cars[3,]))
dataA
test_that("Status of the request is store", {
expect_output(POST_table(dataB, users), "")
})
expect_output(POST_table(dataB, "users"), "")
test_that("Status of the request is store", {
expect_output(POST_table(dataB, "users"), "")
})
test_that("Status of the request is store", {
expect_output(POST_table(dataB, "users"), "")
})
test_that("Status of the request is store", {
expect_message(POST_table(dataB, "users"), "")
})
#' @title POST many lines of json data on a same Mangal table
#'
#' @description POST a list of json data in the Mangal table specified by the user
#'
#' @param data_lst A list with data to be injected, must be json
#' @param table A element, must be the name of the targeted table with ""
#'
#' @return
#'
#' The status and line of failed attempt; if none -> empty
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom httr http_error
#' @importFrom httr http_status
POST_table <- function(data_lst, table) {
# Create vector of status that will contain line + error message
status <- vector()
# Stock responce status for 1 iteration
resp <- character()
# loop : POST one by one each line of the table
for (j in 1:length(data_lst)) {
# Get the status of the POST in resp
resp <- POST_line(data_lst[[j]], table)
# Check if status code other than "Created"
if(httr::http_error(resp) == TRUE){
# If so, paste line + status message
status[length(status)+1] <- paste(j, httr::http_status(resp)[[3]])
}
}
# View wich request failed
if(length(status) != 0) print(paste("entry that failed", status))
else print("No entry failed")
}
print("POST_table extracted")
test_that("Status of the request is store", {
expect_message(POST_table(dataB, "users"), "No entry failed")
})
test_that("Status of the request is store", {
expect_output(POST_table(dataB, "users"), "No entry failed")
})
POST_table(dataB, "users"
)
test_that("Status of the request is store", {
expect_output(POST_table(dataB, "users"), "No entry failed")
expect_output(POST_table(dataB, "users"), "(400) Bad Request")
})
test_that("Status of the request is store", {
expect_output(POST_table(dataB, "users"), "No entry failed")
expect_equal(POST_table(dataB, "users"), "(400) Bad Request")
})
test_that("Status of the request is store", {
expect_output(POST_table(dataB, "users"), "No entry failed")
expect_match(POST_table(dataB, "users"), "(400) Bad Request")
})
test_that("Status of the request is store", {
expect_output(POST_table(dataB, "users"), "No entry failed")
#  expect_match(POST_table(dataB, "users"), "400")
})
test_that("Status of the request is store", {
#  expect_output(POST_table(dataB, "users"), "No entry failed")
expect_match(POST_table(dataB, "users"), "400")
})
test_that("Status of the request is store", {
#  expect_output(POST_table(dataB, "users"), "No entry failed")
expect_match(POST_table(dataB, "users"), "(400)")
})
test_that("Status of the request is store", {
#  expect_output(POST_table(dataB, "users"), "No entry failed")
expect_match(POST_table(dataB, "users"), "(400) Bad Request")
})
test_that("Status of the request is store", {
#  expect_output(POST_table(dataB, "users"), "No entry failed")
expect_match(POST_table(dataB, "users"), "(400)")
})
test_that("Status of the request is store", {
expect_output(POST_table(dataB, "users"), "No entry failed")
expect_match(POST_table(dataB, "users"), "(400)")
})
POST_table(dataB, "error")
POST_table(dataA, "users")
?expect_failure
POST_table(dataA, "users")
#' @title POST many lines of json data on a same Mangal table
#'
#' @description POST a list of json data in the Mangal table specified by the user
#'
#' @param data_lst A list with data to be injected, must be json
#' @param table A element, must be the name of the targeted table with ""
#'
#' @return
#'
#' The status and line of failed attempt; if none -> empty
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom httr http_error
#' @importFrom httr http_status
POST_table <- function(data_lst, table) {
if(typeof(data_lst) != "list") stop("data_lst must be a list")
# Create vector of status that will contain line + error message
status <- vector()
# Stock responce status for 1 iteration
resp <- character()
# loop : POST one by one each line of the table
for (j in 1:length(data_lst)) {
# Get the status of the POST in resp
resp <- POST_line(data_lst[[j]], table)
# Check if status code other than "Created"
if(httr::http_error(resp) == TRUE){
# If so, paste line + status message
status[length(status)+1] <- paste(j, httr::http_status(resp)[[3]])
}
}
# View wich request failed
if(length(status) != 0) print(paste("Entries that failed:", status))
else print("No entry failed")
}
print("POST_table extracted")
test_that("Fail if not a list", {
expect_error(POST_table(dataA, "users"), "data_lst must be a list")
})
dataA <- (cars[1:3,])
dataA
test_that("Fail if not a list", {
expect_error(POST_table(dataA, "users"), "data_lst must be a list")
})
typeof(dataA)
class(dataA)
#' @title POST many lines of json data on a same Mangal table
#'
#' @description POST a list of json data in the Mangal table specified by the user
#'
#' @param data_lst A list with data to be injected, must be json
#' @param table A element, must be the name of the targeted table with ""
#'
#' @return
#'
#' The status and line of failed attempt; if none -> empty
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom httr http_error
#' @importFrom httr http_status
POST_table <- function(data_lst, table) {
if(class(data_lst) != "list") stop("data_lst must be a list")
# Create vector of status that will contain line + error message
status <- vector()
# Stock responce status for 1 iteration
resp <- character()
# loop : POST one by one each line of the table
for (j in 1:length(data_lst)) {
# Get the status of the POST in resp
resp <- POST_line(data_lst[[j]], table)
# Check if status code other than "Created"
if(httr::http_error(resp) == TRUE){
# If so, paste line + status message
status[length(status)+1] <- paste(j, httr::http_status(resp)[[3]])
}
}
# View wich request failed
if(length(status) != 0) print(paste("Entries that failed:", status))
else print("No entry failed")
}
print("POST_table extracted")
test_that("Fail if not a list", {
expect_error(POST_table(dataA, "users"), "data_lst must be a list")
})
View(dataB)
View(data1)
test_that("Warning for object that are not json data", {
expect_error(POST_line(c(1:5), "users"), "'table_lst_line' must be a json")
})
#' @title GET id key from a Mangal entry
#'
#' @description GET primary key of a table entry specified by the user
#'
#' @param table A element, must be the name of the targeted table with ""
#' @param attribute A element, must be the name of the targeted attribute with ""
#' @param value A element, must be the value of the targeted attribute with ""
#'
#' @return
#'
#' The value of the primary key of a specified entry
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom httr modify_url
#' @importFrom httr GET
#' @importFrom httr content
GET_fkey <- function(table, attribute, value){
# Connect to API
server <- "http://localhost:3000"
# Set the table and name as path
url <- httr::modify_url(server, path = paste0("/api/v0/", table, "?", attribute, "=", value))
# Change space in url by "_"
url <- gsub(" ", "%20", url)
# Retreive data from Mangal
data <- httr::GET(url)
data <- httr::content(data)
# Get data into vector
data <- unlist(data)
print(data[[1]])
}
print("GET_fkey extracted")
GET_fkey("users", "name", "Gabriel")
GET_fkey("users", "zzz", "Gabriel")
GET_fkey("zzz", "zzz", "Gabriel")
GET_fkey("table", "zzz", "Gabriel")
GET("localhost:3000/api/v0/table")
#' @title GET id key from a Mangal entry
#'
#' @description GET primary key of a table entry specified by the user
#'
#' @param table A element, must be the name of the targeted table with ""
#' @param attribute A element, must be the name of the targeted attribute with ""
#' @param value A element, must be the value of the targeted attribute with ""
#'
#' @return
#'
#' The value of the primary key of a specified entry
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom httr modify_url
#' @importFrom httr GET
#' @importFrom httr content
GET_fkey <- function(table, attribute, value){
# Connect to API
server <- "http://localhost:3000"
# Set the table and name as path
url <- httr::modify_url(server, path = paste0("/api/v0/", table, "?", attribute, "=", value))
# Change space in url by "_"
url <- gsub(" ", "%20", url)
# Retreive data from Mangal
data <- httr::GET(url)
data <- httr::content(data)
# Get data into vector
data <- unlist(data)
if(is.null(data[[1]])) print("wrong attribute or value inexistant")
else print(data[[1]])
}
print("GET_fkey extracted")
test_that("Traps work", {
test_match(GET_fkey("users", "name", "XYZ"), "wrong attribute or value inexistant")
test_match(GET_fkey("users", "XYZ", "value"), "wrong attribute or value inexistant")
test_match(GET_fkey("XYZ", "name", "value"), "wrong attribute or value inexistant")
})
test_that("Traps work", {
expect_match(GET_fkey("users", "name", "XYZ"), "wrong attribute or value inexistant")
expect_match(GET_fkey("users", "XYZ", "value"), "wrong attribute or value inexistant")
expect_match(GET_fkey("XYZ", "name", "value"), "wrong attribute or value inexistant")
})

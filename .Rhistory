#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom data.table setDT
#' @importFrom httr add_headers
#' @importFrom httr GET
# Create and inject interactions table ##
POST_interactions <- function(inter_df){
# Retrive foreign keys
## taxon_1 & taxon_2
inter_df[, "taxon_1"] <- NA
inter_df[, "taxon_2"] <- NA
for (i in 1:nrow(inter_df)) {
try(inter_df[i, "taxon_1"] <- GET_fkey("taxons", "original_name", as.character(inter_df[i,1])))
try(inter_df[i, "taxon_2"] <- GET_fkey("taxons", "original_name", as.character(inter_df[i,2])))
}
server <- "http://localhost:3000"
config <- httr::add_headers("Content-type" = "application/json")
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/attributes/?name=", attr_inter[[1]])), config = config))) != 0){
inter_df[, "attr_id"] <- GET_fkey("attributes", "name", attr_inter[[1]])
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/environments/?name=", enviro[[1]])), config = config))) != 0){
inter_df[, "environment_id"] <- GET_fkey("environments", "name", enviro[[1]])
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/refs/?doi=", refs[[1]])), config = config))) != 0){
inter_df[, "ref_id"]         <- GET_fkey("refs", "doi", refs[[1]])
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/users/?name=", users[[1]])), config = config))) != 0){
inter_df[, "user_id"]        <- GET_fkey("users", "name", users[[1]])
}
# Remove unused column
inter_df <- inter_df[,3:ncol(inter_df)]
print("keys added")
# attach location to the interaction metadata
geoloc <- geojsonio::geojson_list(c(inter$lat,inter$lon))$features[[1]]$geometry
geoloc$crs <- list(type="name",properties=list(name=paste0("EPSG:",inter$srid)))
inter$localisation <- geoloc
inter[c("lat","lon","srid")] <- NULL
# Set list of interaction + metadata
inter_lst <- list()
for (i in 1:nrow(inter_df)) {
inter_lst[[i]] <- as.list(inter_df[i, ])
inter_lst[[i]] <- c(inter_lst[[i]], inter)
# to JSON
inter_lst[[i]] <- toJSON(inter_lst[[i]], auto_unbox = TRUE, digits = 12)
}
print("metadata added")
# Inject to interactions table
POST_table(inter_lst, "interactions")
rm(inter_lst)
print("interactions done")
}
POST_interactions(hocking_1968)
rm(Data)
devtools::document()
library(mangal)
POST_attributes
devtools::document()
devtools::document()
library(mangal)
library(mangal)
devtools::document()
roxygenize()
roxygen::roxygenize()
library(roxygen2)
roxygenize()
roxygenize()
?roxygenize
roxygenize()
devtools::document()
roxygenize("mangal")
getwd()
setwd("C:/Users/Dell_Gabriel/Desktop/StageGravel/package")
roxygenize("mangal")
roxygenize("mangal")
library(mangal)
roxygenize("mangal")
roxygenize("mangal")
roxygenize("mangal")
POST_networks
library(mangal)
install.packages(mangal)
install_github("gabrielbouleau/mangal.package")
devtools::install_github("gabrielbouleau/mangal.package")
View(POST_networks)
#' @title POST data into the Mangal networks table
#'
#' @description GET foreign keys needed for the 'networks' table then POST the
#'  metadata associated. 'environments', 'users', 'datasets' and 'refs' tables
#'  must be POST before.
#'
#' @return
#'
#' The status of the injection:
#' 'network already in mangal' means that the environment name already have an
#' id
#' 'network done' an id has been created and the injection is succesfull
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom httr modify_url
#' @importFrom httr GET
#' @importFrom httr add_headers
#' @importFrom jsonlite toJSON
#' @importFrom geojsonio geojson_list
#'
#' @export
### BUG : ne saisie pas datasets_id ###
POST_networks(networks_lst)
## Create and inject networks table ##
POST_networks <- function(){
# Check if the networks already exist
server <- "http://localhost:3000"
config <- httr::add_headers("Content-type" = "application/json")
path <- httr::modify_url(server, path = paste0("/api/v0/","networks/?name=",
networks_lst[[1]]))
# Change space in url by "_"
path <- gsub(" ", "%20", path)
# Is retreived content == 0 -> in this case inject data
if (length(content(httr::GET(url = path, config = config))) == 0) {
# Retrive foreign key
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/datasets/?name=", datasets[[1]])), config = config))) != 0){
networks_lst <- c(networks_lst, dataset_id = GET_fkey("datasets", "name", datasets[[1]]))
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/refs/?doi=", refs[[1]])), config = config))) != 0){
networks_lst <- c(networks_lst, ref_id = GET_fkey("refs", "doi", refs[[1]]))
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/environments/?name=", enviro[[1]])), config = config))) != 0){
networks_lst <- c(networks_lst, environment_id = GET_fkey("environments", "name", enviro[[1]]))
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/users/?name=", users[[1]])), config = config))) != 0){
networks_lst <- c(networks_lst, user_id = GET_fkey("users", "name", users[[1]]))
}
# attach location to the network
geoloc <- geojsonio::geojson_list(c(networks_lst$lat,networks_lst$lon))$features[[1]]$geometry
geoloc$crs <- list(type="name",properties=list(name=paste0("EPSG:",networks_lst$srid)))
networks_lst$localisation <- geoloc
# networks_df as a json list
networks_lst[c("lat","lon","srid")] <- NULL
networks_lst <- json_list(networks_lst)
# Inject to networks table
POST_table(networks_lst, "networks")
print("network done")
} else {
print("network already in mangal")
}
}
View(POST_networks)
roxygenize("mangal")
roxygenize("mangal")
roxygenize("mangal")
roxygenize("mangal")
roxygenize("mangal")
library(roxygen2)
roxygenize("mangal")
roxygenize()
roxygenize()
roxygenize()
devtools::install_github("gabrielbouleau/mangal.package")
library(mangal)
setwd("C:/Users/Dell_Gabriel/Desktop/StageGravel/importation_mangal/Test_Hocking_1968")
taxo_back_df <- read.csv2("data/hocking_1968_taxo_back.csv", header = TRUE)
hocking_1968 <- read.csv2("data/hocking_1968_inter.csv", header = TRUE)
taxons_df <- read.csv2("data/hocking_1968_taxons.csv", header = TRUE)
server <- "http://localhost:3000"
config <- httr::add_headers("Content-type" = "application/json")
# Get taxo_id from taxo_back table
for (i in 1:nrow(taxons_df)) {
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/taxo_backs/?name=", taxons_df[i, "name_clear"])), config = config))) == 0){
print(paste0(taxons_df[i, "original_name"], " is not in taxo_backbone, no taxo_id"))
} else {
taxons_df[i, "taxo_id"] <- GET_fkey("taxo_backs", "name", taxons_df[i, "name_clear"])
}
}
library(httr)
# Get taxo_id from taxo_back table
for (i in 1:nrow(taxons_df)) {
if (length(httr::content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/taxo_backs/?name=", taxons_df[i, "name_clear"])), config = config))) == 0){
print(paste0(taxons_df[i, "original_name"], " is not in taxo_backbone, no taxo_id"))
} else {
taxons_df[i, "taxo_id"] <- GET_fkey("taxo_backs", "name", taxons_df[i, "name_clear"])
}
}
# Get taxo_id from taxo_back table
for (i in 1:nrow(taxons_df)) {
if (length(httr::content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/taxo_backs/?name=", taxons_df[i, "name_clear"])), config = config))) == 0){
print(paste0(taxons_df[i, "original_name"], " is not in taxo_backbone, no taxo_id"))
} else {
taxons_df[i, "taxo_id"] <- GET_fkey("taxo_backs", "name", taxons_df[i, "name_clear"])
}
}
View(taxons_df)
taxons_df[, "network_id"] <- GET_fkey("networks", "name", networks[[1]])
print("key added")
# taxon_df as a json list
taxons_lst <- json_list(taxons_df)
View(taxons_lst)
taxons_lst[[1]]
taxons_lst[[1-5]]
taxons_lst[[1:5]]
head(taxons_lst)
head(taxons_lst)
table_lst <- taxons_lst
View(table_lst)
library(roxygen2)
library(roxygen2)
roxygen2::roxygenize()
sessionInfo()
library(stringr)
sessionInfo()
sessionInfo()
packageVersion("stringr")
roxygenize()
library(roxygen2)
install.packages("roxygen2")
library(roxygen2)
roxygenize()
refs <- list(doi    = "test1",
jstor  = "null",
pmid   = "null",
url    = "null",
bibtex = "bibtext long format")
refs[["bibtex"]]
refs[["bibtex]]
refs[[bibtex]]
# Set libraries
library(reshape2)
library(tidyr)
#library(jsonlite)
#library(httr)
library(data.table)
library(rcrossref)
library(taxize)
library(stringr)
library(mangal)
library(jsonlite)
library(httr)
lat  <- -25.445615
lon  <- -48.916297
srid <- 4326
attr_inter <- list(name   = "Presence/Absence",
table_owner = "interactions",
description = "Presence or absence of a recorded interaction",
unit        = "null")
refs <- list(doi    = "10.1590/s0100-84042005000200003",
jstor  = "null",
pmid   = "null",
url    = "http://www.scielo.br/pdf/rbb/v28n2/a03v28n2.pdf",
bibtex = "@article{Kaehler_2005, doi = {10.1590/s0100-84042005000200003}, url = {https://doi.org/10.1590%2Fs0100-84042005000200003}, year = 2005, month = {jun}, publisher = {FapUNIFESP and SciELO}, volume = {28}, number = {2}, pages = {219--228}, author = {Miriam Kaehler and Isabela G. Varassin and Renato Goldenberg}, title = {Polinizacao em uma comunidade de bromelias em floresta atlantica alto-montana no estado do Parana, Brasil}, journal = {Revista Brasileira de Botanica}}")
users <- list(name         = "Gabriel Bergeron",
email        = "gabriel.bergeron3@usherbrooke.ca",
orcid        = "null",
organization = "Universite de Sherbrooke",
type         = "administrator")
enviro <- list(name  = "NAME",
lat   = lat,
lon   = lon,
srid  = srid,
date  = "2002-04-01",
value = 0)
datasets <- list(name        = "kaehler_et_al_2005",
date        = "2002-04-01",
description = "Pollination of a bromeliad community in the high montane Atlantic rain forest in Paran? state, Brazil",
public      = TRUE)
traits <- list(date = "2002-04-01")
networks <- list(name             = "kaehler_et_al_2005",
date             = "2002-04-01",
lat              = lat,
lon              = lon,
srid             = srid,
description      = "Pollination of a bromeliad community in the high montane Atlantic rain forest in Paran? state, Brazil",
public           = TRUE,
all_interactions = FALSE)
inter <- list(taxon_1_level = "taxon",
taxon_2_level = "taxon",
date          = "2002-04-01",
direction     = "directed",
type          = "mutualism",
method        = "Field observation",
description   = "null",
public        = TRUE,
lat           = lat,
lon           = lon,
srid          = srid)
# Check if the networks already exist
server <- "http://localhost:3000"
config <- httr::add_headers("Content-type" = "application/json")
path <- httr::modify_url(server, path = paste0("/api/v0/","networks/?name=",
networks_lst[[1]]))
# Change space in url by "_"
path <- gsub(" ", "%20", path)
# Retrive foreign key
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/datasets/?name=", datasets[[1]])), config = config))) != 0){
networks_lst <- c(networks_lst, dataset_id = GET_fkey("datasets", "name", datasets[[1]]))
}
networks_lst <- networks
# Check if the networks already exist
server <- "http://localhost:3000"
config <- httr::add_headers("Content-type" = "application/json")
path <- httr::modify_url(server, path = paste0("/api/v0/","networks/?name=",
networks_lst[[1]]))
path
# Retrive foreign key
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/datasets/?name=", datasets[[1]])), config = config))) != 0){
networks_lst <- c(networks_lst, dataset_id = GET_fkey("datasets", "name", datasets[[1]]))
}
View(networks_lst)
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/refs/?bibtex=", refs[["bibtex"]])), config = config))) != 0){
networks_lst <- c(networks_lst, ref_id = GET_fkey("refs", "bibtex", refs[["bibtex"]]))
}
length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/environments/?name=", enviro[[1]])), config = config))) != 0
length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/refs/?bibtex=", refs[["bibtex"]])), config = config))) != 0
length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/datasets/?name=", datasets[[1]])), config = config))) != 0
gsub(" ", "%20", paste0(server, "/api/v0/refs/?bibtex=", refs[["bibtex"]]))
View(enviro)
#' @title POST data in the Mangal interactions table
#'
#' @description GET foreign keys needed for the 'interactions' table then POST
#'    the metadata associated. 'attributes', 'environments', 'networks', 'refs'
#'    and 'users' tables must be POST before.
#'
#' @param inter_df A dataframe with three columns: taxon_1, taxon_2 and value
#'
#' @return
#'
#' The status of the injection:
#' 'interactions done' an id has been created for each interactions and the
#' injection is succesfull
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom data.table setDT
#' @importFrom httr add_headers
#' @importFrom httr GET
#'
#' @export
# Create and inject interactions table ##
POST_interactions <- function(inter_df){
# Retrive foreign keys
## taxon_1 & taxon_2
inter_df[, "taxon_1"] <- NA
inter_df[, "taxon_2"] <- NA
for (i in 1:nrow(inter_df)) {
try(inter_df[i, "taxon_1"] <- GET_fkey("taxons", C("original_name", "network_id"), c(as.character(inter_df[i, "sp_taxon_1"]), GET_fkey("networks", "name", networks[["name"]]))))
try(inter_df[i, "taxon_2"] <- GET_fkey("taxons", c("original_name", "network_id"), c(as.character(inter_df[i, "sp_taxon_2"]), GET_fkey("networks", "name", networks[["name"]]))))
}
server <- "http://localhost:3000"
config <- httr::add_headers("Content-type" = "application/json")
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/attributes/?name=", attr_inter[["name"]])), config = config))) != 0){
inter_df[, "attr_id"] <- GET_fkey("attributes", "name", attr_inter[["name"]])
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/environments/?name=", enviro[["name"]])), config = config))) != 0){
inter_df[, "environment_id"] <- GET_fkey("environments", "name", enviro[["name"]])
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/users/?name=", users[["name"]])), config = config))) != 0){
inter_df[, "user_id"]        <- GET_fkey("users", "name", users[["name"]])
}
# Remove unused column
inter_df <- inter_df[,3:ncol(inter_df)]
print("keys added")
# attach location to the interaction metadata
geoloc <- geojsonio::geojson_list(c(inter$lat,inter$lon))$features[[1]]$geometry
geoloc$crs <- list(type="name",properties=list(name=paste0("EPSG:",inter$srid)))
inter$localisation <- geoloc
inter[c("lat","lon","srid")] <- NULL
# Set list of interaction + metadata
inter_lst <- list()
for (i in 1:nrow(inter_df)) {
inter_lst[[i]] <- as.list(inter_df[i, ])
inter_lst[[i]] <- c(inter_lst[[i]], inter)
# to JSON
inter_lst[[i]] <- toJSON(inter_lst[[i]], auto_unbox = TRUE, digits = 12)
}
print("metadata added")
# Inject to interactions table
POST_table(inter_lst, "interactions")
rm(inter_lst)
print("interactions done")
}
table <- "refs"
attribute <- c("name", "year")
value <- c("Witt", "1998")
value
GET_fkey()
GET_fkey(table = table, attribute = attribute, value = value)
if(length(attribute) != length(value)) stop("attribute and value not of the same length")
# Connect to API
server <- "http://localhost:3000"
# Set the table and name as path
url <- httr::modify_url(server, path = paste0("/api/v0/", table, "/?"))
# If lenght of attribute & value > 1, then proceed to complex request
if((length(attribute) == 1 & length(value) == 1) == TRUE){
# Change space in url by "_"
url <- gsub(" ", "%20", paste0(url, attribute, "=", value))
} else {
url <- gsub(" ", "%20", paste0(url, paste0(attribute, "=", value, collapse = "&")))
}
url
# Retreive data from Mangal
data <- httr::GET(url)
data
data <- httr::content(data)
data
if((length(data) > 1) == TRUE) stop(paste0("more than one entry for ",  url))
# Get data into vector
data <- unlist(data)
data
if(is.null(data[[1]] == TRUE)){
print("wrong attribute, check spelling; value or table inexistant, no associated id")
} else {
return(data[[1]])
}
data[[1]]
GET_fkey(table = table, attribute = attribute, value = value)
# Connect to API
server <- "http://localhost:3000"
# Set the table and name as path
url <- httr::modify_url(server, path = paste0("/api/v0/", table, "/?"))
# If lenght of attribute & value > 1, then proceed to complex request
if((length(attribute) == 1 & length(value) == 1) == TRUE){
# Change space in url by "_"
url <- gsub(" ", "%20", paste0(url, attribute, "=", value))
} else {
url <- gsub(" ", "%20", paste0(url, paste0(attribute, "=", value, collapse = "&")))
}
# Retreive data from Mangal
data <- httr::GET(url)
data <- httr::content(data)
if((length(data) > 1) == TRUE) stop(paste0("more than one entry for ",  url))
data
data[[1]]
View(data)
data[[1]][[1]]
#' @title GET id key from a Mangal entry
#'
#' @description GET primary key of a table entry specified by the user
#'
#' @param table A element, must be the name of the targeted table with ""
#' @param attribute A element, must be the name of the targeted attribute with ""
#' @param value A element, must be the value of the targeted attribute with ""
#'
#' @return
#'
#' The value of the primary key of a specified entry
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom httr modify_url
#' @importFrom httr GET
#' @importFrom httr content
#'
#' @export
GET_fkey <- function(table, attribute, value){
if(length(attribute) != length(value)) stop("attribute and value not of the same length")
# Connect to API
server <- "http://localhost:3000"
# Set the table and name as path
url <- httr::modify_url(server, path = paste0("/api/v0/", table, "/?"))
# If lenght of attribute & value > 1, then proceed to complex request
if((length(attribute) == 1 & length(value) == 1) == TRUE){
# Change space in url by "_"
url <- gsub(" ", "%20", paste0(url, attribute, "=", value))
} else {
url <- gsub(" ", "%20", paste0(url, paste0(attribute, "=", value, collapse = "&")))
}
# Retreive data from Mangal
data <- httr::GET(url)
data <- httr::content(data)
if((length(data) > 1) == TRUE) stop(paste0("more than one entry for ",  url))
# Get data into vector
data <- unlist(data)
if(is.null(data[[1]] == TRUE)){
print("wrong attribute, check spelling; value or table inexistant, no associated id")
} else {
return(data[[1]])
}
}
GET_fkey(table = table, attribute = attribute, value = value)
a <- list()
length(a)
length(data)
table <- "attributes"
attribute <- "table_owner"
value <- "interactions"
GET_fkey(table = table, attribute = attribute, value = value)
data
a
is.null(a)
is.null(a[[1]])
a[[1]]
readRDS(".httr-oauth")
# Cache env
mangal.env <- new.env(parent = emptyenv())
# Base URL
mangal.env$prod <- list()
# Config
mangal.env$base <- "/api/v0"
mangal.env$bearer <- "" # oauth
# Production environment
mangal.env$prod$server <- "http://localhost:3000"
mangal.env
mangal.env$prod
mangal.env$prod$server
mangal.env$bearer
mangal.env$base

unit        = "cm")
attr2 <- list(name        = "etamine",
table_owner = "traits",
description = "etamine length",
unit        = "cm")
attr4 <- list(name        = "petale",
table_owner = "traits",
description = "petale length",
unit        = "cm")
attr3 <- list(name        = "sepale",
table_owner = "traits",
description = "setale length",
unit        = "cm")
refs <- list(doi    = "0.2307/3565022",
jstor  = "null",
pmid   = "null",
url    = "http://www.jstor.org/stable/3565022",
bibtex = "bibtext long format")
users <- list(name         = "Gabriel Bergeron",
email        = "gabriel.bergeron3@usherbrooke.ca",
orcid        = "null",
organization = "Universite de Sherbrooke",
type         = "administrator")
enviro <- list(name  = "NAME",
lat   = lat,
lon   = lon,
srid  = srid,
date  = "1111-11-11",
value = 0)
datasets <- list(name        = "Howking_1968",
date        = "1963-06-01",
description = "Insect activity recorded on flower at Lake Hazen, Ellesmere Island, N.W.T., Canada",
public      = TRUE)
traits <- list(date = "1111-11-11")
networks <- list(name             = "NAME",
date             = "1968-06-01",
lat              = lat,
lon              = lon,
srid             = srid,
description      = "null",
public           = FALSE,
all_interactions = FALSE)
inter <- list(taxon_1_level = "individual",
taxon_2_level = "individual",
date          = "1968-06-01",
direction     = "directed",
type          = "unknown",
method        = "Field observations",
description   = "Visit of an insect to a flower",
public        = FALSE,
lat           = lat,
lon           = lon,
srid          = srid)
setwd("C:/Users/Dell_Gabriel/Desktop/StageGravel/importation_mangal/Test_Hocking_1968")
taxo_back_df <- read.csv2("data/hocking_1968_taxo_back.csv", header = TRUE)
hocking_1968 <- read.csv2("data/hocking_1968_inter.csv", header = TRUE)
taxons_df <- read.csv2("data/hocking_1968_taxons.csv", header = TRUE)
traits_df <- read.csv2("data/hocking_1968_traits.csv", header = TRUE)
#------------------------------
# Throwing injection functions
#------------------------------
POST_attributes(attr_inter)
POST_attributes(attr1)
POST_attributes(attr2)
POST_attributes(attr3)
POST_attributes(attr4)
POST_refs()
POST_users()
POST_environments(enviro, attr_inter)
#' @title GET id key from a Mangal entry
#'
#' @description GET primary key of a table entry specified by the user
#'
#' @param table A element, must be the name of the targeted table with ""
#' @param attribute A element, must be the name of the targeted attribute with ""
#' @param value A element, must be the value of the targeted attribute with ""
#'
#' @return
#'
#' The value of the primary key of a specified entry
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom httr modify_url
#' @importFrom httr GET
#' @importFrom httr content
GET_fkey <- function(table, attribute, value){
# Connect to API
server <- "http://localhost:3000"
# Set the table and name as path
url <- httr::modify_url(server, path = paste0("/api/v0/", table, "?", attribute, "=", value))
# Change space in url by "_"
url <- gsub(" ", "%20", url)
# Retreive data from Mangal
data <- httr::GET(url)
data <- httr::content(data)
# Get data into vector
data <- unlist(data)
if(is.null(data[[1]] == TRUE)){
print("wrong attribute, check spelling; value or table inexistant, no associated id")
} else {
return(data[[1]])
}
}
POST_users()
POST_environments(enviro, attr_inter)
POST_datasets()
POST_networks()
POST_taxo_back()
POST_taxons()
POST_traits(traits_df)
POST_interactions(hocking_1968)
#' @title POST data in the Mangal interactions table
#'
#' @description GET foreign keys needed for the 'interactions' table then POST
#'    the metadata associated. 'attributes', 'environments', 'networks', 'refs'
#'    and 'users' tables must be POST before.
#'
#' @param inter_df A dataframe with three columns: taxon_1, taxon_2 and value
#'
#' @return
#'
#' The status of the injection:
#' 'interactions done' an id has been created for each interactions and the
#' injection is succesfull
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom data.table setDT
#' @importFrom httr add_headers
#' @importFrom httr GET
# Create and inject interactions table ##
POST_interactions <- function(inter_df){
# Retrive foreign keys
## taxon_1 & taxon_2
inter_df[, "taxon_1"] <- NA
inter_df[, "taxon_2"] <- NA
for (i in 1:nrow(inter_df)) {
try(inter_df[i, "taxon_1"] <- GET_fkey("taxons", "original_name", as.character(inter_df[i,1])))
try(inter_df[i, "taxon_2"] <- GET_fkey("taxons", "original_name", as.character(inter_df[i,2])))
}
server <- "http://localhost:3000"
config <- httr::add_headers("Content-type" = "application/json")
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/attributes/?name=", attr_inter[[1]])), config = config))) != 0){
inter_df[, "attr_id"] <- GET_fkey("attributes", "name", attr_inter[[1]])
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/environments/?name=", enviro[[1]])), config = config))) != 0){
inter_df[, "environment_id"] <- GET_fkey("environments", "name", enviro[[1]])
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/refs/?doi=", refs[[1]])), config = config))) != 0){
inter_df[, "ref_id"]         <- GET_fkey("refs", "doi", refs[[1]])
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/users/?name=", users[[1]])), config = config))) != 0){
inter_df[, "user_id"]        <- GET_fkey("users", "name", users[[1]])
}
# Remove unused column
inter_df <- inter_df[,3:ncol(inter_df)]
print("keys added")
# attach location to the interaction metadata
geoloc <- geojsonio::geojson_list(c(inter$lat,inter$lon))$features[[1]]$geometry
geoloc$crs <- list(type="name",properties=list(name=paste0("EPSG:",inter$srid)))
inter$localisation <- geoloc
inter[c("lat","lon","srid")] <- NULL
# Set list of interaction + metadata
inter_lst <- list()
for (i in 1:nrow(inter_df)) {
inter_lst[[i]] <- as.list(inter_df[i, ])
inter_lst[[i]] <- c(inter_lst[[i]], inter)
# to JSON
inter_lst[[i]] <- toJSON(inter_lst[[i]], auto_unbox = TRUE, digits = 12)
}
print("metadata added")
# Inject to interactions table
POST_table(inter_lst, "interactions")
rm(inter_lst)
print("interactions done")
}
POST_interactions(hocking_1968)
rm(Data)
devtools::document()
library(mangal)
POST_attributes
devtools::document()
devtools::document()
library(mangal)
library(mangal)
devtools::document()
roxygenize()
roxygen::roxygenize()
library(roxygen2)
roxygenize()
roxygenize()
?roxygenize
roxygenize()
devtools::document()
roxygenize("mangal")
getwd()
setwd("C:/Users/Dell_Gabriel/Desktop/StageGravel/package")
roxygenize("mangal")
roxygenize("mangal")
library(mangal)
roxygenize("mangal")
roxygenize("mangal")
roxygenize("mangal")
POST_networks
library(mangal)
install.packages(mangal)
install_github("gabrielbouleau/mangal.package")
devtools::install_github("gabrielbouleau/mangal.package")
View(POST_networks)
#' @title POST data into the Mangal networks table
#'
#' @description GET foreign keys needed for the 'networks' table then POST the
#'  metadata associated. 'environments', 'users', 'datasets' and 'refs' tables
#'  must be POST before.
#'
#' @return
#'
#' The status of the injection:
#' 'network already in mangal' means that the environment name already have an
#' id
#' 'network done' an id has been created and the injection is succesfull
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom httr modify_url
#' @importFrom httr GET
#' @importFrom httr add_headers
#' @importFrom jsonlite toJSON
#' @importFrom geojsonio geojson_list
#'
#' @export
### BUG : ne saisie pas datasets_id ###
POST_networks(networks_lst)
## Create and inject networks table ##
POST_networks <- function(){
# Check if the networks already exist
server <- "http://localhost:3000"
config <- httr::add_headers("Content-type" = "application/json")
path <- httr::modify_url(server, path = paste0("/api/v0/","networks/?name=",
networks_lst[[1]]))
# Change space in url by "_"
path <- gsub(" ", "%20", path)
# Is retreived content == 0 -> in this case inject data
if (length(content(httr::GET(url = path, config = config))) == 0) {
# Retrive foreign key
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/datasets/?name=", datasets[[1]])), config = config))) != 0){
networks_lst <- c(networks_lst, dataset_id = GET_fkey("datasets", "name", datasets[[1]]))
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/refs/?doi=", refs[[1]])), config = config))) != 0){
networks_lst <- c(networks_lst, ref_id = GET_fkey("refs", "doi", refs[[1]]))
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/environments/?name=", enviro[[1]])), config = config))) != 0){
networks_lst <- c(networks_lst, environment_id = GET_fkey("environments", "name", enviro[[1]]))
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/users/?name=", users[[1]])), config = config))) != 0){
networks_lst <- c(networks_lst, user_id = GET_fkey("users", "name", users[[1]]))
}
# attach location to the network
geoloc <- geojsonio::geojson_list(c(networks_lst$lat,networks_lst$lon))$features[[1]]$geometry
geoloc$crs <- list(type="name",properties=list(name=paste0("EPSG:",networks_lst$srid)))
networks_lst$localisation <- geoloc
# networks_df as a json list
networks_lst[c("lat","lon","srid")] <- NULL
networks_lst <- json_list(networks_lst)
# Inject to networks table
POST_table(networks_lst, "networks")
print("network done")
} else {
print("network already in mangal")
}
}
View(POST_networks)
roxygenize("mangal")
roxygenize("mangal")
roxygenize("mangal")
roxygenize("mangal")
roxygenize("mangal")
library(roxygen2)
roxygenize("mangal")
roxygenize()
roxygenize()
roxygenize()
devtools::install_github("gabrielbouleau/mangal.package")
library(mangal)
setwd("C:/Users/Dell_Gabriel/Desktop/StageGravel/importation_mangal/Test_Hocking_1968")
taxo_back_df <- read.csv2("data/hocking_1968_taxo_back.csv", header = TRUE)
hocking_1968 <- read.csv2("data/hocking_1968_inter.csv", header = TRUE)
taxons_df <- read.csv2("data/hocking_1968_taxons.csv", header = TRUE)
server <- "http://localhost:3000"
config <- httr::add_headers("Content-type" = "application/json")
# Get taxo_id from taxo_back table
for (i in 1:nrow(taxons_df)) {
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/taxo_backs/?name=", taxons_df[i, "name_clear"])), config = config))) == 0){
print(paste0(taxons_df[i, "original_name"], " is not in taxo_backbone, no taxo_id"))
} else {
taxons_df[i, "taxo_id"] <- GET_fkey("taxo_backs", "name", taxons_df[i, "name_clear"])
}
}
library(httr)
# Get taxo_id from taxo_back table
for (i in 1:nrow(taxons_df)) {
if (length(httr::content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/taxo_backs/?name=", taxons_df[i, "name_clear"])), config = config))) == 0){
print(paste0(taxons_df[i, "original_name"], " is not in taxo_backbone, no taxo_id"))
} else {
taxons_df[i, "taxo_id"] <- GET_fkey("taxo_backs", "name", taxons_df[i, "name_clear"])
}
}
# Get taxo_id from taxo_back table
for (i in 1:nrow(taxons_df)) {
if (length(httr::content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/taxo_backs/?name=", taxons_df[i, "name_clear"])), config = config))) == 0){
print(paste0(taxons_df[i, "original_name"], " is not in taxo_backbone, no taxo_id"))
} else {
taxons_df[i, "taxo_id"] <- GET_fkey("taxo_backs", "name", taxons_df[i, "name_clear"])
}
}
View(taxons_df)
taxons_df[, "network_id"] <- GET_fkey("networks", "name", networks[[1]])
print("key added")
# taxon_df as a json list
taxons_lst <- json_list(taxons_df)
View(taxons_lst)
taxons_lst[[1]]
taxons_lst[[1-5]]
taxons_lst[[1:5]]
head(taxons_lst)
head(taxons_lst)
table_lst <- taxons_lst
View(table_lst)
library(roxygen2)
library(roxygen2)
roxygen2::roxygenize()
sessionInfo()
library(stringr)
sessionInfo()
sessionInfo()
packageVersion("stringr")
roxygenize()
library(roxygen2)
install.packages("roxygen2")
library(roxygen2)
roxygenize()
refs <- list(doi    = "test1",
jstor  = "null",
pmid   = "null",
url    = "null",
bibtex = "bibtext long format")
refs[["bibtex"]]
refs[["bibtex]]
refs[[bibtex]]
# Set libraries
library(reshape2)
library(tidyr)
#library(jsonlite)
#library(httr)
library(data.table)
library(rcrossref)
library(taxize)
library(stringr)
library(mangal)
library(jsonlite)
library(httr)
lat  <- -25.445615
lon  <- -48.916297
srid <- 4326
attr_inter <- list(name   = "Presence/Absence",
table_owner = "interactions",
description = "Presence or absence of a recorded interaction",
unit        = "null")
refs <- list(doi    = "10.1590/s0100-84042005000200003",
jstor  = "null",
pmid   = "null",
url    = "http://www.scielo.br/pdf/rbb/v28n2/a03v28n2.pdf",
bibtex = "@article{Kaehler_2005, doi = {10.1590/s0100-84042005000200003}, url = {https://doi.org/10.1590%2Fs0100-84042005000200003}, year = 2005, month = {jun}, publisher = {FapUNIFESP and SciELO}, volume = {28}, number = {2}, pages = {219--228}, author = {Miriam Kaehler and Isabela G. Varassin and Renato Goldenberg}, title = {Polinizacao em uma comunidade de bromelias em floresta atlantica alto-montana no estado do Parana, Brasil}, journal = {Revista Brasileira de Botanica}}")
users <- list(name         = "Gabriel Bergeron",
email        = "gabriel.bergeron3@usherbrooke.ca",
orcid        = "null",
organization = "Universite de Sherbrooke",
type         = "administrator")
enviro <- list(name  = "NAME",
lat   = lat,
lon   = lon,
srid  = srid,
date  = "2002-04-01",
value = 0)
datasets <- list(name        = "kaehler_et_al_2005",
date        = "2002-04-01",
description = "Pollination of a bromeliad community in the high montane Atlantic rain forest in Paran? state, Brazil",
public      = TRUE)
traits <- list(date = "2002-04-01")
networks <- list(name             = "kaehler_et_al_2005",
date             = "2002-04-01",
lat              = lat,
lon              = lon,
srid             = srid,
description      = "Pollination of a bromeliad community in the high montane Atlantic rain forest in Paran? state, Brazil",
public           = TRUE,
all_interactions = FALSE)
inter <- list(taxon_1_level = "taxon",
taxon_2_level = "taxon",
date          = "2002-04-01",
direction     = "directed",
type          = "mutualism",
method        = "Field observation",
description   = "null",
public        = TRUE,
lat           = lat,
lon           = lon,
srid          = srid)
# Check if the networks already exist
server <- "http://localhost:3000"
config <- httr::add_headers("Content-type" = "application/json")
path <- httr::modify_url(server, path = paste0("/api/v0/","networks/?name=",
networks_lst[[1]]))
# Change space in url by "_"
path <- gsub(" ", "%20", path)
# Retrive foreign key
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/datasets/?name=", datasets[[1]])), config = config))) != 0){
networks_lst <- c(networks_lst, dataset_id = GET_fkey("datasets", "name", datasets[[1]]))
}
networks_lst <- networks
# Check if the networks already exist
server <- "http://localhost:3000"
config <- httr::add_headers("Content-type" = "application/json")
path <- httr::modify_url(server, path = paste0("/api/v0/","networks/?name=",
networks_lst[[1]]))
path
# Retrive foreign key
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/datasets/?name=", datasets[[1]])), config = config))) != 0){
networks_lst <- c(networks_lst, dataset_id = GET_fkey("datasets", "name", datasets[[1]]))
}
View(networks_lst)
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/refs/?bibtex=", refs[["bibtex"]])), config = config))) != 0){
networks_lst <- c(networks_lst, ref_id = GET_fkey("refs", "bibtex", refs[["bibtex"]]))
}
length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/environments/?name=", enviro[[1]])), config = config))) != 0
length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/refs/?bibtex=", refs[["bibtex"]])), config = config))) != 0
length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/datasets/?name=", datasets[[1]])), config = config))) != 0
gsub(" ", "%20", paste0(server, "/api/v0/refs/?bibtex=", refs[["bibtex"]]))
View(enviro)
#' @title POST data in the Mangal interactions table
#'
#' @description GET foreign keys needed for the 'interactions' table then POST
#'    the metadata associated. 'attributes', 'environments', 'networks', 'refs'
#'    and 'users' tables must be POST before.
#'
#' @param inter_df A dataframe with three columns: taxon_1, taxon_2 and value
#'
#' @return
#'
#' The status of the injection:
#' 'interactions done' an id has been created for each interactions and the
#' injection is succesfull
#'
#' @author Gabriel Bergeron
#'
#' @keywords database
#'
#' @importFrom data.table setDT
#' @importFrom httr add_headers
#' @importFrom httr GET
#'
#' @export
# Create and inject interactions table ##
POST_interactions <- function(inter_df){
# Retrive foreign keys
## taxon_1 & taxon_2
inter_df[, "taxon_1"] <- NA
inter_df[, "taxon_2"] <- NA
for (i in 1:nrow(inter_df)) {
try(inter_df[i, "taxon_1"] <- GET_fkey("taxons", C("original_name", "network_id"), c(as.character(inter_df[i, "sp_taxon_1"]), GET_fkey("networks", "name", networks[["name"]]))))
try(inter_df[i, "taxon_2"] <- GET_fkey("taxons", c("original_name", "network_id"), c(as.character(inter_df[i, "sp_taxon_2"]), GET_fkey("networks", "name", networks[["name"]]))))
}
server <- "http://localhost:3000"
config <- httr::add_headers("Content-type" = "application/json")
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/attributes/?name=", attr_inter[["name"]])), config = config))) != 0){
inter_df[, "attr_id"] <- GET_fkey("attributes", "name", attr_inter[["name"]])
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/environments/?name=", enviro[["name"]])), config = config))) != 0){
inter_df[, "environment_id"] <- GET_fkey("environments", "name", enviro[["name"]])
}
if (length(content(httr::GET(url = gsub(" ", "%20", paste0(server, "/api/v0/users/?name=", users[["name"]])), config = config))) != 0){
inter_df[, "user_id"]        <- GET_fkey("users", "name", users[["name"]])
}
# Remove unused column
inter_df <- inter_df[,3:ncol(inter_df)]
print("keys added")
# attach location to the interaction metadata
geoloc <- geojsonio::geojson_list(c(inter$lat,inter$lon))$features[[1]]$geometry
geoloc$crs <- list(type="name",properties=list(name=paste0("EPSG:",inter$srid)))
inter$localisation <- geoloc
inter[c("lat","lon","srid")] <- NULL
# Set list of interaction + metadata
inter_lst <- list()
for (i in 1:nrow(inter_df)) {
inter_lst[[i]] <- as.list(inter_df[i, ])
inter_lst[[i]] <- c(inter_lst[[i]], inter)
# to JSON
inter_lst[[i]] <- toJSON(inter_lst[[i]], auto_unbox = TRUE, digits = 12)
}
print("metadata added")
# Inject to interactions table
POST_table(inter_lst, "interactions")
rm(inter_lst)
print("interactions done")
}
